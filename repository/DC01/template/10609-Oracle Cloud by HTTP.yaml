zabbix_export:
  version: '6.0'
  date: '2024-08-25T12:07:58Z'
  groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: 057558a26d934b4683d73a7058499d62
      template: 'Oracle Cloud by HTTP'
      name: 'Oracle Cloud by HTTP'
      description: |
        Monitor resources of Oracle Cloud Infrastructure (OCI) services.
        
        This template handles discovery of various OCI services.
        
        Read the template documentation prior to using this template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      groups:
        - name: Templates/Cloud
      discovery_rules:
        - uuid: 72fa6dfedfd8497298c5930f48594e72
          name: 'Block volumes discovery'
          type: SCRIPT
          key: oci.block.volumes.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('Block volume', 'Get volumes', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/20160918/volumes', '?compartmentId=' + encodeURIComponent(compartment)), ['id', 'displayName', 'lifecycleState', 'freeformTags'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.VOLUME.BLOCK.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.VOLUME.BLOCK.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.VOLUME.BLOCK.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.VOLUME.BLOCK.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover block volumes.'
          host_prototypes:
            - uuid: 5030f7dadd5b40558e07a4545d7346bd
              host: 'OCI Block Volume - {#ID}'
              name: 'OCI Block Volume - {#ID}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Block Volume by HTTP'
              macros:
                - macro: '{$OCI.VOLUME.BLOCK.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Block volume compartment ID.'
                - macro: '{$OCI.VOLUME.BLOCK.ID}'
                  value: '{#ID}'
                  description: 'Block volume ID.'
              tags:
                - tag: oci-block-vol-name
                  value: '{#NAME}'
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.VOLUME.BLOCK}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
        - uuid: 90982afdf2f9430bb1c5a3755d8e6c6d
          name: 'Boot volumes discovery'
          type: SCRIPT
          key: oci.boot.volumes.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('Boot volume', 'Get volumes', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/20160918/bootVolumes', '?compartmentId=' + encodeURIComponent(compartment)), ['id', 'displayName', 'lifecycleState', 'freeformTags'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.VOLUME.BOOT.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.VOLUME.BOOT.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.VOLUME.BOOT.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.VOLUME.BOOT.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover boot volumes.'
          host_prototypes:
            - uuid: 914b808a4a014f6e824a3b9c53f1b492
              host: 'OCI Boot Volume - {#ID}'
              name: 'OCI Boot Volume - {#ID}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Boot Volume by HTTP'
              macros:
                - macro: '{$OCI.VOLUME.BOOT.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Boot volume compartment ID.'
                - macro: '{$OCI.VOLUME.BOOT.ID}'
                  value: '{#ID}'
                  description: 'Boot volume ID.'
              tags:
                - tag: oci-boot-vol-name
                  value: '{#NAME}'
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.VOLUME.BOOT}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
        - uuid: ea4bbd0e9737406693aa0051cf861115
          name: 'Compute instances discovery'
          type: SCRIPT
          key: oci.compute.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('Compute', 'Get instances', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/20160918/instances', '?compartmentId=' + encodeURIComponent(compartment)), ['id', 'displayName', 'lifecycleState', 'freeformTags', 'availabilityDomain'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.COMPUTE.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.COMPUTE.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.COMPUTE.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.COMPUTE.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover compute instances.'
          host_prototypes:
            - uuid: 9337374066e04291b2f94f8ad5470f54
              host: 'OCI Compute - {#ID}'
              name: 'OCI Compute - {#ID}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Compute by HTTP'
              macros:
                - macro: '{$OCI.COMPUTE.AVAILABILITY.DOMAIN}'
                  value: '{#DOMAIN}'
                  description: 'Availability domain for instance.'
                - macro: '{$OCI.COMPUTE.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Compartment ID of OCI compute instance.'
                - macro: '{$OCI.COMPUTE.INSTANCE.ID}'
                  value: '{#ID}'
                  description: 'ID of OCI compute instance.'
              tags:
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
                - tag: oci-compute-name
                  value: '{#NAME}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.COMPUTE}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#DOMAIN}'
              path: $.domain
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
        - uuid: c69611c5b86043b28c8ce2bc0627b377
          name: 'Autonomous database discovery'
          type: SCRIPT
          key: oci.object.autonomous.db.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('Autonomous DB', 'Get DBs', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/20160918/autonomousDatabases', '?compartmentId=' + encodeURIComponent(compartment)), ['id', 'dbName', 'lifecycleState', 'freeformTags'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.AUTONOMOUS.DB.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.AUTONOMOUS.DB.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.AUTONOMOUS.DB.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.AUTONOMOUS.DB.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover autonomous databases.'
          host_prototypes:
            - uuid: 88d0076a057c441ab5a531cfcb650e84
              host: 'OCI Autonomous DB - {#NAME}'
              name: 'OCI Autonomous DB - {#NAME}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Autonomous Database by HTTP'
              macros:
                - macro: '{$OCI.AUTONOMOUS.DB.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Autonomous database compartment ID.'
                - macro: '{$OCI.AUTONOMOUS.DB.ID}'
                  value: '{#ID}'
                  description: 'ID of OCI autonomous database.'
              tags:
                - tag: oci-aut-db-name
                  value: '{#NAME}'
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.AUTONOMOUS.DB.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.AUTONOMOUS.DB}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
        - uuid: e1949f127af04efeb8c192f23e45b58a
          name: 'Object storage discovery'
          type: SCRIPT
          key: oci.object.storage.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('Object storage', 'Get buckets', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            const namespace = JSON.parse(oci.executeRequest('get', '/n', ''));
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/n/' + encodeURIComponent(namespace) + '/b/', '?compartmentId=' + encodeURIComponent(compartment) + '&fields=tags'), ['name', 'freeformTags'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.OBJECT.STORAGE.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.OBJECT.STORAGE.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Discover object storage.'
          host_prototypes:
            - uuid: f71e979727ce42daa80a34da5ffb296f
              host: 'OCI Bucket - {#NAME}'
              name: 'OCI Bucket - {#NAME}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Object Storage by HTTP'
              macros:
                - macro: '{$OCI.OBJECT.STORAGE.BUCKET}'
                  value: '{#NAME}'
                  description: 'Object storage bucket name.'
                - macro: '{$OCI.OBJECT.STORAGE.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Object storage bucket compartment ID.'
              tags:
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
                - tag: oci-obj-store-name
                  value: '{#NAME}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.OBJECT.STORAGE.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.OBJECT.STORAGE}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#NAME}'
              path: $.name
        - uuid: 378d760173924bf48fbc25c74a520a8b
          name: 'Virtual cloud networks discovery'
          type: SCRIPT
          key: oci.vcn.discovery
          delay: 1h
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function prepareCompartments(compartments, tenancy) {
            	if (typeof compartments === 'undefined' || compartments === '') {
            		return [tenancy];
            	} else {
            		return compartments.split(',')
            	}
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'http_status_code'], params);
            var oci = new OCI('VCN', 'Get VCNs', params);
            var compartments = prepareCompartments(params['compartment_ocid'], params['tenancy_ocid']);
            
            var buffer = [];
            compartments.forEach(function (compartment) {
            	Array.prototype.push.apply(buffer, oci.extractData('get', oci.executeRequest('get', '/20160918/vcns', '?compartmentId=' + encodeURIComponent(compartment)), ['id', 'displayName', 'lifecycleState', 'freeformTags'], compartment));
            })
            return JSON.stringify(buffer);
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.VCN.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.VCN.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.VCN.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.VCN.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover virtual cloud networks (VCNs).'
          host_prototypes:
            - uuid: 5329fee3dbc643ebbb99472c67a0a207
              host: 'OCI VCN - {#ID}'
              name: 'OCI VCN - {#ID}'
              group_links:
                - group:
                    name: Templates/Cloud
              templates:
                - name: 'Oracle Cloud Networking by HTTP'
              macros:
                - macro: '{$OCI.VCN.COMPARTMENT.ID}'
                  value: '{#COMPARTMENT}'
                  description: 'Compartment ID of OCI VCN (virtual cloud network).'
                - macro: '{$OCI.VCN.ID}'
                  value: '{#ID}'
                  description: 'ID of the OCI VCN (virtual cloud network).'
              tags:
                - tag: oci-compartment-id
                  value: '{#COMPARTMENT}'
                - tag: oci-vcn-name
                  value: '{#NAME}'
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: compartment_ocid
              value: '{$OCI.API.COMPARTMENT.VCN}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
          lld_macro_paths:
            - lld_macro: '{#COMPARTMENT}'
              path: $.compartment
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
      tags:
        - tag: class
          value: cloud
        - tag: target
          value: oci
        - tag: target
          value: oracle-cloud-infrastructure
      macros:
        - macro: '{$OCI.API.AUTONOMOUS.DB.HOST}'
          description: 'Host for OCI Autonomous Database API endpoint.'
        - macro: '{$OCI.API.COMPARTMENT.AUTONOMOUS.DB}'
          description: 'Compartment OCIDs for autonomous databases. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.COMPARTMENT.COMPUTE}'
          description: 'Compartment OCIDs for compute instances. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.COMPARTMENT.OBJECT.STORAGE}'
          description: 'Compartment OCIDs for object storage buckets. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.COMPARTMENT.VCN}'
          description: 'Compartment OCIDs for virtual cloud networks. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.COMPARTMENT.VOLUME.BLOCK}'
          description: 'Compartment OCIDs for block volumes. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.COMPARTMENT.VOLUME.BOOT}'
          description: 'Compartment OCIDs for boot volumes. Can be a single value or a comma separated list of values.'
        - macro: '{$OCI.API.CORE.HOST}'
          description: 'Host for OCI Core Services API endpoint.'
        - macro: '{$OCI.API.FINGERPRINT}'
          type: SECRET_TEXT
          description: 'Fingerprint of private key.'
        - macro: '{$OCI.API.OBJECT.STORAGE.HOST}'
          description: 'Host for OCI Object Storage API endpoint.'
        - macro: '{$OCI.API.PRIVATE.KEY}'
          type: SECRET_TEXT
          description: 'Entire private key for API access.'
        - macro: '{$OCI.API.TELEMETRY.HOST}'
          description: 'Host for OCI Monitoring API endpoint.'
        - macro: '{$OCI.API.TENANCY}'
          description: 'OCID of tenancy.'
        - macro: '{$OCI.API.USER}'
          description: 'OCID of user.'
        - macro: '{$OCI.AUTONOMOUS.DB.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of autonomous database names to allow in discovery.'
        - macro: '{$OCI.AUTONOMOUS.DB.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of autonomous database names to ignore in discovery.'
        - macro: '{$OCI.AUTONOMOUS.DB.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of autonomous database states to allow in discovery.'
        - macro: '{$OCI.AUTONOMOUS.DB.DISCOVERY.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of autonomous database states to ignore in discovery.'
        - macro: '{$OCI.COMPUTE.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of compute instance names to allow in discovery.'
        - macro: '{$OCI.COMPUTE.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of compute instance names to ignore in discovery.'
        - macro: '{$OCI.COMPUTE.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of compute instance states to allow in discovery.'
        - macro: '{$OCI.COMPUTE.DISCOVERY.STATE.NOT_MATCHES}'
          value: TERMINATED
          description: 'Sets the regex string of compute instance states to ignore in discovery.'
        - macro: '{$OCI.HTTP.PROXY}'
          description: 'Set an HTTP proxy for OCI API requests if needed.'
        - macro: '{$OCI.HTTP.RETURN.CODE.OK}'
          value: '200'
          description: 'Set the HTTP return code that represents an OK response from the API. The default is "200",  but can vary, for example, if a proxy is used.'
        - macro: '{$OCI.OBJECT.STORAGE.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Set an HTTP proxy for OCI API requests if needed.'
        - macro: '{$OCI.OBJECT.STORAGE.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Set an HTTP proxy for OCI API requests if needed.'
        - macro: '{$OCI.VCN.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of virtual cloud network names to allow in discovery.'
        - macro: '{$OCI.VCN.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of virtual cloud network names to ignore in discovery.'
        - macro: '{$OCI.VCN.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of virtual cloud network states to allow in discovery.'
        - macro: '{$OCI.VCN.DISCOVERY.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of virtual cloud network states to ignore in discovery.'
        - macro: '{$OCI.VOLUME.BLOCK.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of block volume names to allow in discovery.'
        - macro: '{$OCI.VOLUME.BLOCK.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of block volume names to ignore in discovery.'
        - macro: '{$OCI.VOLUME.BLOCK.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of block volume states to allow in discovery.'
        - macro: '{$OCI.VOLUME.BLOCK.DISCOVERY.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of block volume states to ignore in discovery.'
        - macro: '{$OCI.VOLUME.BOOT.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of boot volume names to allow in discovery.'
        - macro: '{$OCI.VOLUME.BOOT.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of boot volume names to ignore in discovery.'
        - macro: '{$OCI.VOLUME.BOOT.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of boot volume states to allow in discovery.'
        - macro: '{$OCI.VOLUME.BOOT.DISCOVERY.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of boot volume states to ignore in discovery.'
