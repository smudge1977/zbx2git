zabbix_export:
  version: '6.0'
  date: '2024-08-25T12:38:18Z'
  groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: 62d99b55585e41dd89736f5f46074dcb
      template: 'Oracle Cloud Networking by HTTP'
      name: 'Oracle Cloud Networking by HTTP'
      description: |
        This template monitors Oracle Cloud Infrastructure (OCI) single virtual network card availability and discovers
        attached subnets and monitors their availability.
        
        This template is not meant to be used independently, but together with Oracle Cloud by HTTP as a template for 
        LLD host prototypes.
        
        Read the template documentation prior to using this template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      groups:
        - name: Templates/Cloud
      items:
        - uuid: 7b2fdfb034ba4657a731ab11ffa175f6
          name: 'OCI VCN: Get VCN state'
          type: SCRIPT
          key: oci.vcn.state.get
          delay: 5m
          history: 7d
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'vcn_id', 'http_status_code'], params);
            var oci = new OCI('VCN', 'Get VCN status', params);
            
            return JSON.stringify(oci.extractData('get', oci.executeRequest('get', '/20160918/vcns/' + encodeURIComponent(params['vcn_id']), ''), 'lifecycleState'));
          description: 'State of the virtual cloud network.'
          valuemap:
            name: 'Lifecycle state'
          preprocessing:
            - type: STR_REPLACE
              parameters:
                - '"'
                - ''
            - type: JAVASCRIPT
              parameters:
                - |
                  const idx = {
                  	'PROVISIONING': 1,
                  	'AVAILABLE': 2,
                  	'TERMINATING': 3,
                  	'TERMINATED': 4,
                  	'UPDATING': 5
                  };
                  
                  return typeof idx[value] === 'undefined' ? 0 : idx[value];
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
          timeout: 10s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
            - name: vcn_id
              value: '{$OCI.VCN.ID}'
          tags:
            - tag: component
              value: network
          triggers:
            - uuid: 8a5a94ea28db43df93e85d26703f9e7c
              expression: 'min(/Oracle Cloud Networking by HTTP/oci.vcn.state.get,5m) = 3 or min(/Oracle Cloud Networking by HTTP/oci.vcn.state.get,5m) = 4'
              name: 'OCI VCN: VCN state terminated'
              priority: HIGH
              description: 'Virtual cloud network state is "terminated" or "terminating".'
              tags:
                - tag: scope
                  value: availability
            - uuid: 80c3f4d6696c40a78ddb2c00378eeae1
              expression: 'min(/Oracle Cloud Networking by HTTP/oci.vcn.state.get,5m) = 0'
              name: 'OCI VCN: VCN state unknown'
              priority: WARNING
              description: 'Virtual cloud network state is unknown.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 83236aeedf5e4ba39f0425c21f745690
          name: 'OCI VCN: Get subnets'
          type: SCRIPT
          key: oci.vcn.subnets.get
          delay: 5m
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            function validateZabbixParams(requiredParams, allParams) {
            	requiredParams.forEach(function (field) {
            		if (typeof allParams !== 'object' || typeof allParams[field] === 'undefined' || allParams[field] === '') {
            			throw 'Required param is not set: ' + field + '.';
            		}
            	});
            }
            
            function OCI(service, action, params) {
            	this.zabbixLogPrefix = '[ OCI ] [ ' + service + ' ] [ ' + action + ' ]';
            	this.request = new HttpRequest();
            
            	this.hash = function (string) {
            		return sha256(string);
            	};
            
            	this.sign = function (string) {
            		return sign('sha256', params['private_key'], string);
            	};
            
            	this.encode = function (hash) {
            		const hexArr = hash.match(/.{1,2}/g);
            		var uInt8Array = new Uint8Array(hexArr.length);
            		hexArr.forEach(function (hex, idx) {
            			uInt8Array[idx] = parseInt(hex, 16);
            		});
            		return btoa(uInt8Array);
            	};
            
            	this.getDate = function () {
            		const weekdayShortList = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            		const monthShortList = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            		const today = new Date();
            		return weekdayShortList[today.getUTCDay()] + ', ' + today.getUTCDate() + ' ' + monthShortList[today.getUTCMonth()] + ' ' + today.getUTCFullYear() + ' ' + today.getUTCHours() + ':' + today.getUTCMinutes() + ':' + today.getUTCSeconds() + ' GMT';
            	};
            
            	this.executeRequest = function (httpMethod, apiPath, apiParams, mql, namespace) {
            		var headers = '(request-target) date host';
            		const contentTypeHeader = 'content-type: application/json';
            		const dateHeader = 'date: ' + this.getDate();
            		const hostHeader = 'host: ' + params['api_host'];
            		const requestTarget = '(request-target): ' + httpMethod + ' ' + apiPath + apiParams;
            		var signingString = requestTarget + '\n' + dateHeader + '\n' + hostHeader;
            		var reqHeaders = [contentTypeHeader, dateHeader];
            
            		if (httpMethod === 'post') {
            			var body = JSON.stringify({
            				'namespace': namespace,
            				'query': mql
            			});
            			headers = headers + ' x-content-sha256 content-type content-length';
            			const bodyHeader = 'x-content-sha256: ' + this.encode(this.hash(body));
            			const bodyLengthHeader = 'content-length: ' + body.length;
            			signingString = signingString + '\n' + bodyHeader + '\n' + contentTypeHeader + '\n' + bodyLengthHeader;
            			reqHeaders.push(bodyHeader, bodyLengthHeader);
            		}
            
            		const signature = this.encode(this.sign(signingString));
            
            		reqHeaders.push('Authorization: Signature version="1",keyId="' + params['tenancy_ocid'] + '/' + params['user_ocid'] + '/' + params['fingerprint'] + '",algorithm="rsa-sha256",headers="' + headers + '",signature="' + signature + '"');
            		for (var header = 0, headerLength = reqHeaders.length; header < headerLength; header++) {
            			this.request.addHeader(reqHeaders[header]);
            		}
            
            		if (params['http_proxy']) {
            			this.request.setProxy(params['http_proxy']);
            			Zabbix.log(4, this.zabbixLogPrefix + ' Using http proxy: ' + params['http_proxy']);
            		}
            
            		if (httpMethod === 'post') {
            			var apiRateLimitExceeded = false;
            			do {
            				const response = this.request.post('https://' + params['api_host'] + apiPath + apiParams, body);
            
            				try {
            					if (JSON.parse(response)['code'] === 'TooManyRequests') {
            
            						apiRateLimitExceeded = true;
            						Zabbix.sleep(1000);
            					} else {
            						apiRateLimitExceeded = false;
            					}
            				} catch (error) {
            					Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the response: ' + JSON.stringify(response));
            					throw 'Could not parse the response. See logs for more information.';
            				}
            			} while (apiRateLimitExceeded);
            		} else {
            			const response = this.request.get('https://' + params['api_host'] + apiPath + apiParams);
            		}
            
            		this.request.clearHeader();
            
            		if (this.request.getStatus() === parseInt(params['http_status_code'])) {
            			return response;
            		} else {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Unexpected HTTP response code: ' + this.request.getStatus());
            			throw 'Unexpected HTTP response code: ' + this.request.getStatus();
            		}
            	};
            
            	this.extractData = function (httpMethod, data, keys, compartment) {
            		try {
            			data = JSON.parse(data);
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not parse the received JSON object: ' + data);
            			throw 'Could not parse received JSON object. See logs for more information.';
            		}
            
            		if (typeof keys == 'object') {
            			var returnBuffer = [];
            			for (var dataObj = 0, dataLength = data.length; dataObj < dataLength; dataObj++) {
            
            				var objectBuffer = {};
            				for (var key = 0, keysLength = keys.length; key < keysLength; key++) {
            					if (data[dataObj][keys[key]] || data[dataObj][keys[key]] == null) {
            						objectBuffer[keys[key].match(/^[a-z]+$|[A-Z][a-z]+$/)[0].toLowerCase()] = data[dataObj][keys[key]];
            					} else {
            						Zabbix.log(3, this.zabbixLogPrefix + ' Received an unexpected JSON object. Could not get value for key "' + keys[key] + '" in JSON: ' + JSON.stringify(data[dataObj]));
            						throw 'Received an unexpected JSON object. See logs for more information.';
            					}
            				}
            				if (typeof compartment != 'undefined' && compartment != '') objectBuffer['compartment'] = compartment;
            				returnBuffer.push(objectBuffer);
            			}
            			return returnBuffer;
            		}
            
            		try {
            			if (httpMethod === 'get') {
            				return data[keys];
            			} else {
            				if (data.length === 0) {
            					return 0;
            				}
            				data = data[0][keys];
            				return data[data.length - 1]['value'];
            			}
            		} catch (error) {
            			Zabbix.log(3, this.zabbixLogPrefix + ' Could not find key "' + keys + '" in JSON: ' + JSON.stringify(data));
            			throw 'Could not find required key in JSON object. See logs for more information.';
            		}
            	};
            }
            
            
            const params = JSON.parse(value);
            validateZabbixParams(['tenancy_ocid', 'user_ocid', 'private_key', 'fingerprint', 'api_host', 'vcn_id', 'http_status_code', 'compartment_id'], params);
            var oci = new OCI('VCN', 'Get subnets', params);
            
            return JSON.stringify(oci.extractData('get', oci.executeRequest('get', '/20160918/subnets', '?compartmentId=' + encodeURIComponent(params['compartment_id']) + '&vcnId=' + encodeURIComponent(params['vcn_id'])), ['id', 'displayName', 'lifecycleState', 'freeformTags']));
          description: 'Get data about subnets linked to the particular VCN.'
          timeout: 30s
          parameters:
            - name: api_host
              value: '{$OCI.API.CORE.HOST}'
            - name: compartment_id
              value: '{$OCI.VCN.COMPARTMENT.ID}'
            - name: fingerprint
              value: '{$OCI.API.FINGERPRINT}'
            - name: http_proxy
              value: '{$OCI.HTTP.PROXY}'
            - name: http_status_code
              value: '{$OCI.HTTP.RETURN.CODE.OK}'
            - name: private_key
              value: '{$OCI.API.PRIVATE.KEY}'
            - name: tenancy_ocid
              value: '{$OCI.API.TENANCY}'
            - name: user_ocid
              value: '{$OCI.API.USER}'
            - name: vcn_id
              value: '{$OCI.VCN.ID}'
          tags:
            - tag: component
              value: raw
      discovery_rules:
        - uuid: 6aca3a2d8b9a4231ae9364611ed4df82
          name: 'Subnet discovery'
          type: DEPENDENT
          key: oci.vcn.subnet.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#NAME}'
                value: '{$OCI.VCN.SUBNET.DISCOVERY.NAME.MATCHES}'
                formulaid: A
              - macro: '{#NAME}'
                value: '{$OCI.VCN.SUBNET.DISCOVERY.NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#STATE}'
                value: '{$OCI.VCN.SUBNET.DISCOVERY.STATE.MATCHES}'
                formulaid: C
              - macro: '{#STATE}'
                value: '{$OCI.VCN.SUBNET.DISCOVERY.STATE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discover subnets linked to the particular VCN.'
          item_prototypes:
            - uuid: 759c6bff98fb4cb3bc8c9269513339bf
              name: 'Subnet [{#NAME}]: Get subnet state'
              type: DEPENDENT
              key: 'oci.vcn.subnet.state[{#ID}]'
              delay: '0'
              history: 7d
              description: 'Current state of subnet.'
              valuemap:
                name: 'Lifecycle state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$..[?(@.id == ''{#ID}'')].state.first()'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      const idx = {
                      	'PROVISIONING': 1,
                      	'AVAILABLE': 2,
                      	'TERMINATING': 3,
                      	'TERMINATED': 4
                      };
                      
                      return typeof idx[value] === 'undefined' ? 0 : idx[value];
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 1h
              master_item:
                key: oci.vcn.subnets.get
              tags:
                - tag: component
                  value: network
                - tag: subnet
                  value: '{#ID}'
              trigger_prototypes:
                - uuid: f048db860c0c4134acdbcbf19ea554eb
                  expression: 'min(/Oracle Cloud Networking by HTTP/oci.vcn.subnet.state[{#ID}],5m) = 3 or min(/Oracle Cloud Networking by HTTP/oci.vcn.subnet.state[{#ID}],5m) = 4'
                  name: 'Subnet [{#NAME}]: Subnet state terminated'
                  priority: HIGH
                  description: 'Virtual cloud network subnet state is "terminated" or "terminating".'
                  tags:
                    - tag: scope
                      value: availability
                - uuid: d34e5b8c571b41f9ba5dc11453431860
                  expression: 'min(/Oracle Cloud Networking by HTTP/oci.vcn.subnet.state[{#ID}],5m) = 0'
                  name: 'Subnet [{#NAME}]: Subnet state unknown'
                  priority: WARNING
                  description: 'Virtual cloud network subnet state is unknown.'
                  tags:
                    - tag: scope
                      value: availability
          master_item:
            key: oci.vcn.subnets.get
          lld_macro_paths:
            - lld_macro: '{#ID}'
              path: $.id
            - lld_macro: '{#NAME}'
              path: $.name
            - lld_macro: '{#STATE}'
              path: $.state
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1h
      tags:
        - tag: class
          value: cloud
        - tag: target
          value: oci
        - tag: target
          value: oracle-cloud-infrastructure
      macros:
        - macro: '{$OCI.HTTP.PROXY}'
          description: 'Set an HTTP proxy for OCI API requests if needed.'
        - macro: '{$OCI.HTTP.RETURN.CODE.OK}'
          value: '200'
          description: 'Set the HTTP return code that represents an OK response from the API. The default is "200",  but can vary, for example, if a proxy is used.'
        - macro: '{$OCI.VCN.SUBNET.DISCOVERY.NAME.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of VCN subnet names to allow in discovery.'
        - macro: '{$OCI.VCN.SUBNET.DISCOVERY.NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of VCN subnet names to ignore in discovery.'
        - macro: '{$OCI.VCN.SUBNET.DISCOVERY.STATE.MATCHES}'
          value: '.*'
          description: 'Sets the regex string of VCN subnet states to allow in discovery.'
        - macro: '{$OCI.VCN.SUBNET.DISCOVERY.STATE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Sets the regex string of VCN subnet states to ignore in discovery.'
      valuemaps:
        - uuid: abf7b45647ee4a339df92bf06b12f0df
          name: 'Lifecycle state'
          mappings:
            - value: '0'
              newvalue: Unknown
            - value: '1'
              newvalue: Provisioning
            - value: '2'
              newvalue: Available
            - value: '3'
              newvalue: Terminating
            - value: '4'
              newvalue: Terminated
            - value: '5'
              newvalue: Updating
