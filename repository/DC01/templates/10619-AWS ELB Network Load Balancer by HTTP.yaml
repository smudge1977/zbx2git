zabbix_export:
  version: '6.0'
  date: '2024-08-25T12:38:18Z'
  groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: 4c7d0c6e342b40458611bdb6e9dd958f
      template: 'AWS ELB Network Load Balancer by HTTP'
      name: 'AWS ELB Network Load Balancer by HTTP'
      description: |
        The template is designed to monitor AWS ELB Network Load Balancer by HTTP via Zabbix, and it works without any external scripts.
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      groups:
        - name: Templates/Cloud
      items:
        - uuid: 170a4e084c3748dfa1cfcbb1b168ff4c
          name: 'AWS ELB NLB: Active Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
            TCP connections are not terminated at the load balancer, so a client opening a TCP connection to a target counts as a single flow.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: fd00c2998ae145ab821acde0a1515fbb
          name: 'AWS ELB NLB: Active Flow Count TCP'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_tcp
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent TCP flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
            TCP connections are not terminated at the load balancer, so a client opening a TCP connection to a target counts as a single flow.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tcp
        - uuid: 31ae92c16e5643d3a67f392661518723
          name: 'AWS ELB NLB: Active Flow Count TLS'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_tls
          delay: '0'
          history: 7d
          description: |
            The total number of concurrent TLS flows (or connections) from clients to targets.
            This metric includes connections in the `SYN_SENT` and `ESTABLISHED` states.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tls
        - uuid: 7ba1f232eacc41cfa6e38939128b9ee1
          name: 'AWS ELB NLB: Active Flow Count UDP'
          type: DEPENDENT
          key: aws.elb.nlb.active_flow_count_udp
          delay: '0'
          history: 7d
          description: 'The total number of concurrent UDP flows (or connections) from clients to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveFlowCount_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: udp
        - uuid: 397ce9711a404da48ebdfde65c24ff3b
          name: 'AWS ELB NLB: Get alarms check'
          type: DEPENDENT
          key: aws.elb.nlb.alarms.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the alarm data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.nlb.get_alarms
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 4319dc0d484b456a9343535db3c079f4
              expression: 'length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarms.check))>0'
              name: 'AWS ELB NLB: Failed to get alarms data'
              event_name: 'AWS ELB NLB: Failed to get CloudWatch alarms for Network Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch alarms for Network Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: b2ef5e512e674a969853b389f308664e
          name: 'AWS ELB NLB: Consumed LCUs'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: 33c9d9d275c04811b7dcb6806e8a9d9a
          name: 'AWS ELB NLB: Consumed LCUs TCP'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_tcp
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for TCP.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: tcp
        - uuid: bbcd303cbf654dc68fb40216994eef84
          name: 'AWS ELB NLB: Consumed LCUs TLS'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_tls
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for TLS.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: tls
        - uuid: 90742c0ffb4844668f59a75f26132b18
          name: 'AWS ELB NLB: Consumed LCUs UDP'
          type: DEPENDENT
          key: aws.elb.nlb.capacity_units_udp
          delay: '0'
          history: 7d
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer for UDP.
            You pay for the number of LCUs that you use per hour.
            More information on Elastic Load Balancing pricing here: https://aws.amazon.com/elasticloadbalancing/pricing/
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: capacity
            - tag: component
              value: udp
        - uuid: 6bbe06db758f40da9c2e0cb825b2aac3
          name: 'AWS ELB NLB: Client TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.client_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: 'The total number of TLS handshakes that failed during negotiation between a client and a TLS listener.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ClientTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tls
        - uuid: 6d74c1a68ea9476dadc39b785f333d5d
          name: 'AWS CloudWatch: Get ELB NLB alarms data'
          type: SCRIPT
          key: aws.elb.nlb.get_alarms
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials is not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			host = service + '.' + region + '.amazonaws.com',
            			canonical_uri = '/',
            			canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            			signed_headers = 'content-encoding;host;x-amz-date',
            			canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest(),
            			url = 'https://' + host + canonical_uri + '?' + params;
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		if (response[0] === '<') {
            			try {
            				response = XML.toJson(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		return response;
            	},
            
            	getAlarms: function () {
            		var payload = {
            			'Action': 'DescribeAlarms',
            			'Version': '2010-08-01',
            			'MaxRecords': 100
            		},
            			result = [];
            
            		while (payload.NextToken !== '') {
            			var alarms = AWS.getField(AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload)), 'DescribeAlarmsResponse.DescribeAlarmsResult');
            			payload.NextToken = alarms.NextToken || '';
            			alarms_list = AWS.getField(alarms, 'MetricAlarms');
            			regex = /loadbalancer\/(.+)$/;
            
            			if (!Array.isArray(alarms_list))
            				alarms_list = [alarms_list]
            			alarms_list.forEach(function (alarm) {
            				var dimensions = alarm.Dimensions;
            
            				Zabbix.log(4, '[ AWS ELB ] dimensions: ' + JSON.stringify(dimensions));
            				if (Array.isArray(alarm.Metrics)) {
            					alarm.Metrics.forEach(function (metric) {
            						if (typeof metric.MetricStat === 'object' && metric.MetricStat !== null
            							&& typeof metric.MetricStat.Metric === 'object' && metric.MetricStat.Metric !== null
            							&& Array.isArray(metric.MetricStat.Metric.Dimensions)) {
            							dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
            						}
            					});
            				}
            				for (var i in dimensions) {
            					if (dimensions[i].Name === 'LoadBalancer' && dimensions[i].Value === AWS.params.arn.match(regex)[1]) {
            						result.push(alarm);
            						break;
            					}
            				}
            			});
            		}
            
            		return result;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            
            	return JSON.stringify(AWS.getAlarms());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Alarms ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: '`DescribeAlarms` API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html'
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 76d374302b29430c8fe5813656ffd928
          name: 'AWS ELB NLB: Get metrics data'
          type: SCRIPT
          key: aws.elb.nlb.get_metrics
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            	request_period: 60,
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	renderMetricQuery: function (period, arn) {
            		var metrics_list = [
            			'ActiveFlowCount:Average',
            			'ActiveFlowCount_TCP:Average',
            			'ActiveFlowCount_TLS:Average',
            			'ActiveFlowCount_UDP:Average',
            			'ClientTLSNegotiationErrorCount:Sum',
            			'ConsumedLCUs:Sum',
            			'ConsumedLCUs_TCP:Sum',
            			'ConsumedLCUs_TLS:Sum',
            			'ConsumedLCUs_UDP:Sum',
            			'NewFlowCount:Sum',
            			'NewFlowCount_TCP:Sum',
            			'NewFlowCount_TLS:Sum',
            			'NewFlowCount_UDP:Sum',
            			'PeakPacketsPerSecond:Maximum',
            			'PortAllocationErrorCount:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_ICMP:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_TCP:Sum',
            			'SecurityGroupBlockedFlowCount_Inbound_UDP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_ICMP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_TCP:Sum',
            			'SecurityGroupBlockedFlowCount_Outbound_UDP:Sum',
            			'ProcessedBytes:Sum',
            			'ProcessedBytes_TCP:Sum',
            			'ProcessedBytes_TLS:Sum',
            			'ProcessedBytes_UDP:Sum',
            			'ProcessedPackets:Sum',
            			'TargetTLSNegotiationErrorCount:Sum',
            			'TCP_Client_Reset_Count:Sum',
            			'TCP_ELB_Reset_Count:Sum',
            			'TCP_Target_Reset_Count:Sum',
            			'UnhealthyRoutingFlowCount:Sum'
            		],
            			regex = /loadbalancer\/(.+)$/;
            
            		var metric_payload = [];
            		metrics_list.forEach(function (metric, index) {
            			var parts = metric.split(':', 2);
            			metric_payload.push({
            				'Id': 'm' + index,
            				'MetricStat': {
            					'Metric': {
            						'MetricName': parts[0],
            						'Namespace': 'AWS/NetworkELB',
            						'Dimensions': [
            							{
            								'Name': 'LoadBalancer',
            								'Value': arn.match(regex)[1],
            							}
            						]
            					},
            					'Period': period,
            					'Stat': parts[1],
            				}
            			});
            		});
            
            		return metric_payload;
            	},
            
            	request: function (method, region, service, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		else {
            			data = JSON.stringify(data)
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            
            		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri;
            
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.post(url, data);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	getMetricsData: function () {
            		var end_time = Math.floor((new Date().getTime()) / 1000),
            			start_time = end_time - AWS.request_period * 60;
            		payload = {
            			'StartTime': start_time,
            			'EndTime': end_time,
            			'ScanBy': 'TimestampDescending',
            			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn)
            		};
            
            		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.getMetricsData());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Get metrics] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB Network Load Balancer metrics.
            Full metrics list related to Network Load Balancer: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-cloudwatch-metrics.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: d80c238267744bc9b46de217acd93842
          name: 'AWS ELB NLB: Get target groups'
          type: SCRIPT
          key: aws.elb.nlb.get_target_groups
          delay: 0s;m/30
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get(AWS.metadata);
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = JSON.stringify([]);
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            		canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
            		url = 'https://' + host + canonical_uri + '?' + params;
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.get(url);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	listTargetGroups: function () {
            		var lld_array = [],
            			regex = /targetgroup\/(.+)$/,
            			payload = {
            				'Action': 'DescribeTargetGroups',
            				'LoadBalancerArn': AWS.params.arn,
            				'Version': '2015-12-01'
            			};
            		targets = AWS.getField(AWS.request('GET', AWS.params.region, 'elasticloadbalancing', AWS.prepareParams(payload), ''), 'DescribeTargetGroupsResponse.DescribeTargetGroupsResult.TargetGroups');
            
            		if (!Array.isArray(targets))
            			targets = [targets]
            
            		targets.forEach(function (targets) {
            			lld_array.push(
            				{
            					target_name: AWS.getField(targets, 'TargetGroupName'),
            					target_arn: AWS.getField(targets, 'TargetGroupArn').match(regex)[0],
            					type: AWS.getField(targets, 'TargetType'),
            					protocol: AWS.getField(targets, 'Protocol')
            				}
            			)
            		});
            
            		return lld_array;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.listTargetGroups());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Target groups ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB target group.
            `DescribeTargetGroups` API method: https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: 13516270f6124bf09a308bc20565528c
          name: 'AWS ELB NLB: Get metrics check'
          type: DEPENDENT
          key: aws.elb.nlb.metrics.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check that the Network Load Balancer metrics data has been received correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: c2ba26fed3324a2bb9b90493a99db088
              expression: 'length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.metrics.check))>0'
              name: 'AWS ELB NLB: Failed to get metrics data'
              event_name: 'AWS ELB NLB: Failed to get CloudWatch metrics for Network Load Balancer'
              opdata: 'Current value: {ITEM.LASTVALUE1}'
              priority: WARNING
              description: 'Failed to get CloudWatch metrics for Network Load Balancer.'
              tags:
                - tag: scope
                  value: availability
        - uuid: 38a2dca1cca34a1988dd8713552c952b
          name: 'AWS ELB NLB: New Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count
          delay: '0'
          history: 7d
          description: 'The total number of new flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: a34d5ded1ec445b89a681a39b854b6cd
          name: 'AWS ELB NLB: New Flow Count TCP'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_tcp
          delay: '0'
          history: 7d
          description: 'The total number of new TCP flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tcp
        - uuid: 25ec5461aa3f477c8698d3b31ed3263c
          name: 'AWS ELB NLB: New Flow Count TLS'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_tls
          delay: '0'
          history: 7d
          description: 'The total number of new TLS flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: tls
        - uuid: 3f8fb9c0de524d0b9f157a9291fd7f27
          name: 'AWS ELB NLB: New Flow Count UDP'
          type: DEPENDENT
          key: aws.elb.nlb.new_flow_count_udp
          delay: '0'
          history: 7d
          description: 'The total number of new UDP flows (or connections) established from clients to targets in the specified time period.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewFlowCount_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: udp
        - uuid: ffda7926a52c438c8195f70d772a4f7e
          name: 'AWS ELB NLB: Peak Packets per second'
          type: DEPENDENT
          key: aws.elb.nlb.peak_packets.rate
          delay: '0'
          history: 7d
          description: |
            Highest average packet rate (packets processed per second), calculated every 10 seconds during the sampling window.
            This metric includes health check traffic.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "PeakPacketsPerSecond")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: traffic
        - uuid: e83d4c875f414628987989a8e5e27c9e
          name: 'AWS ELB NLB: Port Allocation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.port_allocation_error_count
          delay: '0'
          history: 7d
          description: |
            The total number of ephemeral port allocation errors during a client IP translation operation. A non-zero value indicates dropped client connections.
            Note: Network Load Balancers support 55,000 simultaneous connections or about 55,000 connections per minute to each unique target (IP address and port) when performing client address translation.
            To fix port allocation errors, add more targets to the target group.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "PortAllocationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: connections
            - tag: component
              value: health
        - uuid: 38cca57bd12048558d8569e6a9d18492
          name: 'AWS ELB NLB: Processed Bytes'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by the load balancer, including TCP/IP headers. This count includes traffic to and from targets, minus health check traffic.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
        - uuid: a6b272d40c3d4b72adcced4aadaa607c
          name: 'AWS ELB NLB: Processed Bytes TCP'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_tcp
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by TCP listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: tcp
            - tag: component
              value: traffic
        - uuid: c1e6456cd23446808299396f6368d6a9
          name: 'AWS ELB NLB: Processed Bytes TLS'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_tls
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by TLS listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_TLS")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: tls
            - tag: component
              value: traffic
        - uuid: 5c5e1be4725d4908adc0c506c98a6cab
          name: 'AWS ELB NLB: Processed Bytes UDP'
          type: DEPENDENT
          key: aws.elb.nlb.processed_bytes_udp
          delay: '0'
          history: 7d
          units: B
          description: 'The total number of bytes processed by UDP listeners.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
            - tag: component
              value: udp
        - uuid: c41394db6dba4693b4c19aebdc2e8f69
          name: 'AWS ELB NLB: Processed Packets'
          type: DEPENDENT
          key: aws.elb.nlb.processed_packets
          delay: '0'
          history: 7d
          description: 'The total number of packets processed by the load balancer. This count includes traffic to and from targets, including health check traffic.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedPackets")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: traffic
        - uuid: 28bb42c1af9d4ee782a4ac1e75194293
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Inbound ICMP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_icmp
          delay: '0'
          history: 7d
          description: 'The number of new ICMP messages rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_ICMP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: icmp
            - tag: component
              value: security-group
        - uuid: 95db8688978d4fc0b3a54c01c34cd0c7
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Inbound TCP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_tcp
          delay: '0'
          history: 7d
          description: 'The number of new TCP flows rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: tcp
        - uuid: 287e26627214470bba9589af506ca832
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Inbound UDP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_inbound_udp
          delay: '0'
          history: 7d
          description: 'The number of new UDP flows rejected by the inbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Inbound_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: udp
        - uuid: 65a6fb4771114377bcdf93dc09665b2b
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Outbound ICMP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_icmp
          delay: '0'
          history: 7d
          description: 'The number of new ICMP messages rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_ICMP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: icmp
            - tag: component
              value: security-group
        - uuid: 343b254cfc1a48cc8e401cd3514c76b3
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Outbound TCP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_tcp
          delay: '0'
          history: 7d
          description: 'The number of new TCP flows rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_TCP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: tcp
        - uuid: 5a9126687a964f969270bc1855081a7a
          name: 'AWS ELB NLB: Security Group Blocked Flow Count Outbound UDP'
          type: DEPENDENT
          key: aws.elb.nlb.sg_blocked_outbound_udp
          delay: '0'
          history: 7d
          description: 'The number of new UDP flows rejected by the outbound rules of the load balancer security groups.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "SecurityGroupBlockedFlowCount_Outbound_UDP")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: security-group
            - tag: component
              value: udp
        - uuid: 583872d175174881a8cdcede4fe641e7
          name: 'AWS ELB NLB: Target TLS Negotiation Error Count'
          type: DEPENDENT
          key: aws.elb.nlb.target_tls_negotiation_error_count
          delay: '0'
          history: 7d
          description: 'The total number of TLS handshakes that failed during negotiation between a TLS listener and a target.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tls
        - uuid: 035021358b9f4ae2b0478d5168fc1501
          name: 'AWS ELB NLB: TCP Client Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_client_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets sent from a client to a target.
            These resets are generated by the client and forwarded by the load balancer.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_Client_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 84f23b89fb414731979941a9a4701025
          name: 'AWS ELB NLB: TCP ELB Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_elb_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets generated by the load balancer.
            For more information, see: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-troubleshooting.html#elb-reset-count-metric
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_ELB_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 3318c330736e406c9eec5f581f3fc59b
          name: 'AWS ELB NLB: TCP Target Reset Count'
          type: DEPENDENT
          key: aws.elb.nlb.tcp_target_reset_count
          delay: '0'
          history: 7d
          description: |
            The total number of reset (RST) packets sent from a target to a client.
            These resets are generated by the target and forwarded by the load balancer.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TCP_Target_Reset_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
            - tag: component
              value: tcp
        - uuid: 706019d7a11e48a9aaa1b5484c93fd8e
          name: 'AWS ELB NLB: Unhealthy Routing Flow Count'
          type: DEPENDENT
          key: aws.elb.nlb.unhealthy_routing_flow_count
          delay: '0'
          history: 7d
          description: 'The number of flows (or connections) that are routed using the routing failover action (fail open).'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "UnhealthyRoutingFlowCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.nlb.get_metrics
          tags:
            - tag: component
              value: health
      discovery_rules:
        - uuid: 92bef05094464c16b03b37f1f797d436
          name: 'Load Balancer alarm discovery'
          type: DEPENDENT
          key: aws.elb.nlb.alarms.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
                formulaid: A
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
                formulaid: C
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Used for the discovery of alarm balancers.'
          item_prototypes:
            - uuid: c9f5791fe83743739ab74289126c7843
              name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}]: Get metrics'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              delay: '0'
              history: '0'
              trends: '0'
              value_type: TEXT
              description: 'Get metrics about the alarm state and its reason.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.AlarmName == "{#ALARM_NAME}")].first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: aws.elb.nlb.get_alarms
              tags:
                - tag: component
                  value: raw
            - uuid: 3e039e2d86654095b0c9fa93f7273cab
              name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}]: State'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.state["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The value of the alarm state. Possible values:
                0 - OK;
                1 - INSUFFICIENT_DATA;
                2 - ALARM.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              valuemap:
                name: 'Alarm state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateValue
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '3'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];
                      
                      return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());
              master_item:
                key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
              trigger_prototypes:
                - uuid: 0df06bb3cad742368204984c83f3c161
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state["{#ALARM_NAME}"])=1'
                  name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}] has ''Insufficient data'' state'
                  event_name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}] has ''Insufficient data'' state'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: INFO
                  description: 'Either the alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.'
                  tags:
                    - tag: scope
                      value: notice
            - uuid: 8be7e86d50be4324ac6b7b8f20350eb0
              name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}]: State reason'
              type: DEPENDENT
              key: 'aws.elb.nlb.alarm.state_reason["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              trends: '0'
              value_type: TEXT
              description: |
                An explanation for the alarm state reason in text format.
                Alarm description:
                `{#ALARM_DESCRIPTION}`
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateReason
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.elb.nlb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
          trigger_prototypes:
            - uuid: a4558b07342b4e758cde7866e9027acf
              expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state["{#ALARM_NAME}"])=2 and length(last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.alarm.state_reason["{#ALARM_NAME}"]))>0'
              name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}] has ''Alarm'' state'
              event_name: 'AWS ELB NLB Alarms: [{#ALARM_NAME}] has ''Alarm'' state (reason: {ITEM.LASTVALUE2})'
              opdata: 'Reason: {ITEM.LASTVALUE2}'
              priority: AVERAGE
              description: |
                The alarm `{#ALARM_NAME}` is in the ALARM state.
                Reason: `{ITEM.LASTVALUE2}`
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: aws.elb.nlb.get_alarms
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var result = [];
                  var alarms = JSON.parse(value);
                  
                  alarms.forEach(function(alarm) {
                  
                   result.push({
                  '{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
                  '{#ALARM_NAME}': alarm.AlarmName,
                  '{#ALARM_PERIOD}': alarm.Period,
                  '{#METRIC_NAME}': alarm.MetricName,
                  '{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
                    });
                  });
                  
                  return JSON.stringify(result);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: bc0fa68299464e2ebb031b005bd7041a
          name: 'Target groups discovery'
          type: DEPENDENT
          key: aws.elb.nlb.target_groups.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Used for the discovery of `{$AWS.ELB.TARGET.GROUP.NAME}` target groups.'
          item_prototypes:
            - uuid: 9438a03b48bd4617a2363f83f758f107
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Get metrics'
              type: SCRIPT
              key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: 0s;m/5
              history: '0'
              trends: '0'
              value_type: TEXT
              params: |
                var AWS = {
                	params: {},
                	metadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',
                	request_period: 60,
                
                	getField: function (data, path) {
                		var steps = path.split('.');
                		for (var i = 0; i < steps.length; i++) {
                			var step = steps[i];
                			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                				throw 'Required field was not found: ' + path;
                			}
                
                			data = data[step];
                		}
                
                		return data;
                	},
                
                	setParams: function (params) {
                		AWS.params['proxy'] = params.proxy;
                		switch (AWS.getField(params, 'auth_type')) {
                			case 'role_base':
                				AWS.params['auth_type'] = 'role_base';
                				var request = new HttpRequest();
                				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                					request.setProxy(AWS.params.proxy);
                				}
                				var IamRoleName = request.get(AWS.metadata);
                
                				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                					throw 'Error getting security credentials from instance metadata. Role not found.';
                				}
                
                				credentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));
                
                				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                					throw 'Error getting security credentials from instance metadata.';
                				}
                
                				try {
                					credentials = JSON.parse(credentials);
                				}
                				catch (error) {
                					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                				}
                
                				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                						throw 'Required credentials are not set: "' + field + '".';
                					};
                					AWS.params[field] = credentials[field];
                				});
                				break;
                			case 'access_key':
                			default:
                				AWS.params['auth_type'] = 'access_key';
                				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                						throw 'Required param is not set: "' + field + '".';
                					}
                					AWS.params[field] = params[field];
                				});
                		}
                		['region', 'arn', 'target_arn'].forEach(function (field) {
                			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                				throw 'Required param is not set: "' + field + '".';
                			}
                			AWS.params[field] = params[field];
                		});
                	},
                
                	sign: function (key, message) {
                		var hex = hmac('sha256', key, message);
                
                		if ((hex.length % 2) === 1) {
                			throw 'Invalid length of a hex string!';
                		}
                
                		var result = new Int8Array(hex.length / 2);
                		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                			result[b] = parseInt(hex.substring(i, i + 2), 16);
                		}
                
                		return result;
                	},
                
                	renderMetricQuery: function (period, arn, target_arn) {
                		var metrics_list = [
                			'HealthyHostCount:Minimum',
                			'UnHealthyHostCount:Maximum'
                		],
                			regex = /loadbalancer\/(.+)$/;
                
                		var metric_payload = [];
                		metrics_list.forEach(function (metric, index) {
                			var parts = metric.split(':', 2);
                			metric_payload.push({
                				'Id': 'm' + index,
                				'MetricStat': {
                					'Metric': {
                						'MetricName': parts[0],
                						'Namespace': 'AWS/NetworkELB',
                						'Dimensions': [
                							{
                								'Name': 'LoadBalancer',
                								'Value': arn.match(regex)[1],
                							},
                							{
                								'Name': 'TargetGroup',
                								'Value': target_arn
                							}
                						]
                					},
                					'Period': period,
                					'Stat': parts[1],
                				}
                			});
                		});
                
                		return metric_payload;
                	},
                
                	request: function (method, region, service, data) {
                		if (typeof data === 'undefined' || data === null) {
                			data = JSON.stringify([]);
                		}
                		else {
                			data = JSON.stringify(data)
                		}
                		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                			date = amzdate.replace(/T\d+Z/, ''),
                			canonical_uri = '/',
                			host = service + '.' + region + '.amazonaws.com';
                
                		if (AWS.params.auth_type === 'role_base') {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
                		} else {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date';
                		}
                
                		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data);
                		url = 'https://' + host + canonical_uri;
                
                		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                
                		key = AWS.sign(key, region);
                		key = AWS.sign(key, service);
                		key = AWS.sign(key, 'aws4_request');
                
                		var request = new HttpRequest();
                
                		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                			request.setProxy(AWS.params.proxy);
                		}
                		request.addHeader('x-amz-date: ' + amzdate);
                		request.addHeader('x-amz-content-sha256:' + sha256(data));
                		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
                		request.addHeader('Accept: application/json');
                		request.addHeader('Content-Type: application/json');
                		request.addHeader('Content-Encoding: amz-1.0');
                		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                		if (AWS.params.auth_type === 'role_base')
                			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                
                		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
                		response = request.post(url, data);
                		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
                		if (request.getStatus() !== 200) {
                			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                		}
                
                		return JSON.parse(response);
                	},
                
                	getMetricsData: function () {
                		var end_time = Math.floor((new Date().getTime()) / 1000),
                			start_time = end_time - AWS.request_period * 60;
                		payload = {
                			'StartTime': start_time,
                			'EndTime': end_time,
                			'ScanBy': 'TimestampDescending',
                			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn, AWS.params.target_arn)
                		};
                
                		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
                	}
                };
                
                try {
                	AWS.setParams(JSON.parse(value));
                	return JSON.stringify(AWS.getMetricsData());
                }
                catch (error) {
                	error += (String(error).endsWith('.')) ? '' : '.';
                	Zabbix.log(3, '[ AWS ELB Get targets group metrics] ERROR: ' + error);
                
                	return JSON.stringify({ 'error': error });
                }
              description: |
                Get the metrics of the ELB target group `{#AWS.ELB.TARGET.GROUP.NAME}`.
                Full list of metrics related to AWS ELB here: https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-cloudwatch-metrics.html#user-authentication-metric-table
              preprocessing:
                - type: CHECK_NOT_SUPPORTED
                  parameters:
                    - ''
              timeout: '{$AWS.DATA.TIMEOUT}'
              parameters:
                - name: AccessKeyId
                  value: '{$AWS.ACCESS.KEY.ID}'
                - name: arn
                  value: '{$AWS.ELB.ARN}'
                - name: auth_type
                  value: '{$AWS.AUTH_TYPE}'
                - name: proxy
                  value: '{$AWS.PROXY}'
                - name: region
                  value: '{$AWS.REGION}'
                - name: SecretAccessKey
                  value: '{$AWS.SECRET.ACCESS.KEY}'
                - name: target_arn
                  value: '{#AWS.ELB.TARGET.GROUP.ARN}'
              tags:
                - tag: component
                  value: raw
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 8a42548bf31843acb0b021dfa0cf7f38
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered healthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              trigger_prototypes:
                - uuid: dd527fbba0a84a1b8abe77dc34f7474c
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) = 0'
                  name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Target have become unhealthy'
                  event_name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host Count = 0'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: AVERAGE
                  description: 'This trigger helps in identifying when your targets have become unhealthy.'
                  tags:
                    - tag: scope
                      value: availability
            - uuid: b5e01700b1a14cd1bcfb676c69490f86
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host Count'
              type: DEPENDENT
              key: 'aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered unhealthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnHealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.nlb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              trigger_prototypes:
                - uuid: 8de0720e39eb4759bec17431a596c3d4
                  expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) > {$AWS.ELB.UNHEALTHY.HOST.MAX}'
                  name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Target have unhealthy host'
                  event_name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host Count > {$AWS.ELB.UNHEALTHY.HOST.MAX}'
                  opdata: 'Current value: {ITEM.LASTVALUE1}'
                  priority: WARNING
                  description: 'This trigger allows you to become aware when there are no more registered targets.'
                  dependencies:
                    - name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Target have become unhealthy'
                      expression: 'last(/AWS ELB Network Load Balancer by HTTP/aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]) = 0'
                  tags:
                    - tag: scope
                      value: availability
          graph_prototypes:
            - uuid: c83f16408b0e42b1b985fa02e00d49da
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Network Load Balancer by HTTP'
                    key: 'aws.elb.nlb.target_groups.healthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 2ddcf506cb344d58a8b2b555c0b90952
              name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Network Load Balancer by HTTP'
                    key: 'aws.elb.nlb.target_groups.unhealthy_host_count["{#AWS.ELB.TARGET.GROUP.NAME}"]'
          master_item:
            key: aws.elb.nlb.get_target_groups
          lld_macro_paths:
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.ARN}'
              path: $.target_arn
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
              path: $.target_name
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
              path: $.protocol
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              path: $.type
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: target
          value: aws
        - tag: target
          value: elb
        - tag: target
          value: nlb
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: access_key
          description: 'Authorization method. Possible values: `role_base`, `access_key`.'
        - macro: '{$AWS.DATA.TIMEOUT}'
          value: 60s
          description: 'API response timeout.'
        - macro: '{$AWS.ELB.ARN}'
          description: 'Amazon Resource Names (ARN) of the load balancer.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable target groups by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered target groups by name.'
        - macro: '{$AWS.ELB.UNHEALTHY.HOST.MAX}'
          value: '0'
          description: 'Maximum number of unhealthy hosts for a trigger expression.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets the HTTP proxy value. If this macro is empty, no proxy is used.'
        - macro: '{$AWS.REGION}'
          value: us-west-1
          description: 'AWS Network Load Balancer region code.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          description: 'Secret access key.'
      dashboards:
        - uuid: 3b69323b2b8940b0a1fd0ae2ae2dc156
          name: 'Overview AWS ELB Network Load Balancer'
          pages:
            - name: 'AWS ELB NLB: Main'
              widgets:
                - type: ITEM
                  name: 'Port Allocation Error Count'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: adv_conf
                      value: '1'
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        key: aws.elb.nlb.port_allocation_error_count
                    - type: INTEGER
                      name: show
                      value: '2'
                - type: GRAPH_CLASSIC
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Peak Packets per second'
                - type: GRAPH_CLASSIC
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count'
                - type: GRAPH_CLASSIC
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs and Processed Bytes'
                - type: GRAPH_CLASSIC
                  'y': '20'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count ICMP'
                - type: GRAPH_PROTOTYPE
                  x: '6'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Healthy Host'
                - type: GRAPH_PROTOTYPE
                  x: '12'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB Target Groups: [{#AWS.ELB.TARGET.GROUP.NAME}]: Unhealthy Host'
                - type: ITEM
                  name: 'Unhealthy Routing Flow Count'
                  x: '18'
                  width: '6'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: adv_conf
                      value: '1'
                    - type: INTEGER
                      name: decimal_places
                      value: '0'
                    - type: ITEM
                      name: itemid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        key: aws.elb.nlb.unhealthy_routing_flow_count
                    - type: INTEGER
                      name: show
                      value: '2'
            - name: 'AWS ELB NLB: TCP'
              widgets:
                - type: GRAPH_CLASSIC
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: TCP Reset Count'
                - type: GRAPH_CLASSIC
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs TCP and Processed Bytes TCP'
                - type: GRAPH_CLASSIC
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count TCP'
                - type: GRAPH_CLASSIC
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count TCP'
            - name: 'AWS ELB NLB: TLS'
              widgets:
                - type: GRAPH_CLASSIC
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: TLS Negotiation Error Count'
                - type: GRAPH_CLASSIC
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs TLS and Processed Bytes TLS'
                - type: GRAPH_CLASSIC
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count TLS'
            - name: 'AWS ELB NLB: UDP'
              widgets:
                - type: GRAPH_CLASSIC
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Consumed LCUs UDP and Processed Bytes UDP'
                - type: GRAPH_CLASSIC
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Concurrent Flows Count UDP'
                - type: GRAPH_CLASSIC
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Network Load Balancer by HTTP'
                        name: 'AWS ELB NLB: Security Group Blocked Flow Count UDP'
      valuemaps:
        - uuid: e0e5308401bd4abfa79ba604c0481d2a
          name: 'Alarm state'
          mappings:
            - value: '0'
              newvalue: OK
            - value: '1'
              newvalue: 'Insufficient data'
            - value: '2'
              newvalue: Alarm
            - value: '255'
              newvalue: Unknown
  graphs:
    - uuid: 07118e148b0744ec98750733d1b5284c
      name: 'AWS ELB NLB: Concurrent Flows Count'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count
    - uuid: a13750d46d834d65a881396ecedaa813
      name: 'AWS ELB NLB: Concurrent Flows Count TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tcp
    - uuid: 3b4ccb4dc50b4bf49ef45b517a65e6e8
      name: 'AWS ELB NLB: Concurrent Flows Count TLS'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_tls
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tls
    - uuid: 670bad5c2264431cb60b3a0b9c5cf111
      name: 'AWS ELB NLB: Concurrent Flows Count UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.active_flow_count_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_udp
    - uuid: c16c89c1a5da4aafbd8151f982cade2d
      name: 'AWS ELB NLB: Consumed LCUs and Processed Bytes'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes
    - uuid: c5718fb3ddfd4642ba2dbd914a1fe6ac
      name: 'AWS ELB NLB: Consumed LCUs TCP and Processed Bytes TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_tcp
    - uuid: 7b5d11acc0dc4d19b4d0a797570400e7
      name: 'AWS ELB NLB: Consumed LCUs TLS and Processed Bytes TLS'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_tls
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_tls
    - uuid: 355fb45cbaef4dfb9050ca84fbfba83b
      name: 'AWS ELB NLB: Consumed LCUs UDP and Processed Bytes UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.capacity_units_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.processed_bytes_udp
    - uuid: e2023c7d365b45629ccf61f853229bcb
      name: 'AWS ELB NLB: New Flow Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tcp
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_tls
        - sortorder: '3'
          drawtype: BOLD_LINE
          color: F7941D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.new_flow_count_udp
    - uuid: 457264f4a11a4a4dbac3314875b04ac0
      name: 'AWS ELB NLB: Peak Packets per second'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.peak_packets.rate
    - uuid: 7db2aa4f6f454b06ba3c9e01259a1a24
      name: 'AWS ELB NLB: Security Group Blocked Flow Count ICMP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_icmp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_icmp
    - uuid: bf724b8819804cb385f6448f2f6133ac
      name: 'AWS ELB NLB: Security Group Blocked Flow Count TCP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_tcp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_tcp
    - uuid: 3162f3656a154c9280bda0539c6e102c
      name: 'AWS ELB NLB: Security Group Blocked Flow Count UDP'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_inbound_udp
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.sg_blocked_outbound_udp
    - uuid: 561b3f02b2964c5d8dce2b2b6d2556d4
      name: 'AWS ELB NLB: TCP Reset Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_client_reset_count
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_elb_reset_count
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.tcp_target_reset_count
    - uuid: 87c58ec6a1ee4c9abde81e10af999d79
      name: 'AWS ELB NLB: TLS Negotiation Error Count'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.client_tls_negotiation_error_count
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          item:
            host: 'AWS ELB Network Load Balancer by HTTP'
            key: aws.elb.nlb.target_tls_negotiation_error_count
